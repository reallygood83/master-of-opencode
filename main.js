/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OpenCodePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  provider: "anthropic",
  model: "claude-sonnet-4-5",
  customApiBaseUrl: "",
  contextWindowLimit: 128e3,
  executionMode: "spawn",
  serverPort: 3e3,
  opencodePath: "",
  theme: "adaptive",
  notifications: true,
  favoriteModels: [
    "anthropic/claude-sonnet-4-5",
    "xai/grok-4-1-fast",
    "google/gemini-3-pro-high"
  ]
};
var IMAGE_CAPABLE_MODELS = [
  "anthropic/claude-sonnet-4-5",
  "anthropic/claude-opus-4-5",
  "xai/grok-4-1-fast",
  "google/gemini-3-pro-high",
  "google/gemini-3-pro-medium",
  "google/gemini-3-pro-low",
  "google/gemini-3-flash",
  "google/gemini-3-flash-lite"
];

// src/SettingsTab.ts
var import_obsidian = require("obsidian");
var OpenCodeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.newProviderValue = "";
    this.plugin = plugin;
  }
  async loadAuthProviders(authListEl) {
    try {
      if (this.plugin.processManager) {
        const authProviders = await this.plugin.processManager.getAuthProviders();
        if (authProviders.length > 0) {
          authProviders.forEach((auth) => {
            const authItem = authListEl.createDiv({ cls: "opencode-auth-item" });
            authItem.createSpan({ text: `\u2705 ${auth.provider}`, cls: "auth-provider-name" });
            authItem.createSpan({ text: `(${auth.type})`, cls: "auth-provider-type" });
            authItem.createEl("button", {
              cls: "auth-logout-btn",
              text: "Logout"
            }).addEventListener("click", async () => {
              if (this.plugin.processManager) {
                const result = await this.plugin.processManager.logoutProvider(auth.provider);
                new import_obsidian.Notice(result.message);
                if (result.success) {
                  this.display();
                }
              }
            });
          });
        } else {
          authListEl.createEl("p", {
            text: "No authenticated providers found. Add one below.",
            cls: "setting-item-description"
          });
        }
      }
    } catch (error) {
      authListEl.createEl("p", {
        text: `Failed to load auth status: ${error}`,
        cls: "opencode-error"
      });
    }
  }
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Master of OpenCode" });
    containerEl.createEl("p", {
      text: "Configure your AI-powered development assistant",
      cls: "setting-item-description"
    });
    containerEl.createEl("h2", { text: "\u{1F50C} OpenCode Connection" });
    const statusEl = containerEl.createDiv({ cls: "opencode-status" });
    const state = (_a = this.plugin.processManager) == null ? void 0 : _a.getState();
    new import_obsidian.Setting(containerEl).setName("OpenCode Path").setDesc("Path to opencode binary (auto-detected if empty)").addText((text) => text.setPlaceholder("/opt/homebrew/bin/opencode").setValue(this.plugin.settings.opencodePath).onChange(async (value) => {
      this.plugin.settings.opencodePath = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
      try {
        if (!this.plugin.processManager) {
          throw new Error("ProcessManager not initialized");
        }
        const result = await this.plugin.processManager.checkOpenCodeInstalled();
        statusEl.empty();
        if (result.installed) {
          statusEl.createEl("span", {
            text: `\u2705 OpenCode found at: ${result.path} (v${result.version})`,
            cls: "opencode-status-running"
          });
        } else {
          statusEl.createEl("span", {
            text: result.error ? `\u274C Error: ${result.error}` : "\u274C OpenCode not found. Please install.",
            cls: "opencode-status-stopped"
          });
        }
      } catch (error) {
        statusEl.empty();
        statusEl.createEl("span", {
          text: `\u274C Error checking: ${error}`,
          cls: "opencode-status-stopped"
        });
      }
    })).addButton((button) => button.setButtonText("\u{1F4E5} Install OpenCode").setWarning().onClick(async () => {
      button.setDisabled(true);
      button.setButtonText("Installing...");
      try {
        if (!this.plugin.processManager) {
          throw new Error("ProcessManager not initialized");
        }
        const result = await this.plugin.processManager.installOpenCode();
        statusEl.empty();
        if (result.success) {
          this.plugin.settings.opencodePath = result.path || "";
          await this.plugin.saveSettings();
          statusEl.createEl("span", {
            text: `\u2705 ${result.message}`,
            cls: "opencode-status-running"
          });
          this.display();
        } else {
          statusEl.createEl("span", {
            text: `\u274C ${result.message}`,
            cls: "opencode-status-stopped"
          });
        }
      } catch (error) {
        statusEl.empty();
        statusEl.createEl("span", {
          text: `\u274C Installation failed: ${error}`,
          cls: "opencode-status-stopped"
        });
      } finally {
        button.setDisabled(false);
        button.setButtonText("\u{1F4E5} Install OpenCode");
      }
    }));
    if (state == null ? void 0 : state.sessionID) {
      statusEl.createEl("span", {
        text: "\u{1F7E2} Session Active",
        cls: "opencode-status-running"
      });
      statusEl.createEl("span", {
        text: ` (${state.sessionID.substring(0, 15)}...)`,
        cls: "opencode-status-detail"
      });
    } else {
      statusEl.createEl("span", {
        text: "\u26AA Ready",
        cls: "opencode-status-stopped"
      });
    }
    new import_obsidian.Setting(containerEl).setName("Active Session").setDesc("Manage current CLI session").addButton((button) => button.setButtonText("Clear Session").onClick(async () => {
      var _a2;
      (_a2 = this.plugin.processManager) == null ? void 0 : _a2.clearSession();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Execution Mode").setDesc("How to connect to OpenCode").addDropdown((dropdown) => {
      dropdown.addOption("spawn", "CLI Spawner (Default)").addOption("server", "Server Mode (Advanced)").setValue(this.plugin.settings.executionMode).onChange(async (value) => {
        this.plugin.settings.executionMode = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.executionMode === "server") {
      new import_obsidian.Setting(containerEl).setName("Server Port").setDesc("Port for OpenCode server").addText((text) => text.setPlaceholder("3000").setValue(String(this.plugin.settings.serverPort)).onChange(async (value) => {
        this.plugin.settings.serverPort = parseInt(value) || 3e3;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h2", { text: "\u{1F916} AI Model Settings" });
    new import_obsidian.Setting(containerEl).setName("Authentication Status").setDesc("Manage your OpenCode CLI provider credentials").addButton((button) => button.setButtonText("\u{1F504} Refresh Auth Status").onClick(async () => {
      button.setDisabled(true);
      button.setButtonText("Refreshing...");
      this.display();
      button.setDisabled(false);
      button.setButtonText("\u{1F504} Refresh Auth Status");
    }));
    const authListEl = containerEl.createDiv({ cls: "opencode-auth-list" });
    this.loadAuthProviders(authListEl);
    new import_obsidian.Setting(containerEl).setName("Add Provider Login").setDesc("Log in to a new AI provider (will open browser)").addText((text) => text.setPlaceholder("anthropic, google, xai, etc.").setValue("").onChange((value) => {
      this.newProviderValue = value;
    })).addButton((button) => button.setButtonText("Login").setCta().onClick(async () => {
      if (this.newProviderValue && this.newProviderValue.trim()) {
        if (this.plugin.processManager) {
          const result = await this.plugin.processManager.loginProvider(this.newProviderValue.trim());
          new import_obsidian.Notice(result.message);
          if (result.success) {
            this.display();
          }
        }
      }
    }));
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc('Select "Default" to use your CLI configuration, or override with a specific provider.').addDropdown((dropdown) => {
      const providers = {
        "default": "Default (Use OpenCode CLI Config)",
        "anthropic": "Anthropic (Claude)",
        "openai": "OpenAI (GPT)",
        "google": "Google (Gemini)",
        "ollama": "Ollama (Local)",
        "custom": "Custom Provider"
      };
      Object.entries(providers).forEach(([value, name]) => {
        dropdown.addOption(value, name);
      });
      dropdown.setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select model from OpenCode CLI (refresh after login)").addDropdown((dropdown) => {
      if (this.plugin.settings.provider === "default") {
        dropdown.addOption("default", "Use CLI Default");
        dropdown.setValue("default");
      } else {
        const provider = this.plugin.settings.provider;
        dropdown.addOption(`${provider}/model-name`, `Select ${provider} model from CLI`);
      }
      dropdown.onChange(async (value) => {
        if (this.plugin.settings.provider !== "default") {
          this.plugin.settings.model = value.split("/")[1] || value;
        }
        await this.plugin.saveSettings();
      });
    }).addText((text) => text.setPlaceholder("Or enter custom model ID (provider/model)").setValue(this.plugin.settings.model).onChange(async (value) => {
      this.plugin.settings.model = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom API Base URL").setDesc("For local LLMs or custom proxies (leave empty for default)").addText((text) => text.setPlaceholder("https://api.example.com/v1").setValue(this.plugin.settings.customApiBaseUrl).onChange(async (value) => {
      this.plugin.settings.customApiBaseUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Context Window Limit").setDesc("Maximum tokens for context (depends on model)").addSlider((slider) => slider.setLimits(4096, 2e5, 4096).setValue(this.plugin.settings.contextWindowLimit).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.contextWindowLimit = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u{1F3A8} UI & Appearance" });
    new import_obsidian.Setting(containerEl).setName("Theme").setDesc("Chat interface theme").addDropdown((dropdown) => {
      dropdown.addOption("adaptive", "Adaptive (Follow Obsidian)").addOption("dark", "Dark").addOption("light", "Light").setValue(this.plugin.settings.theme).onChange(async (value) => {
        this.plugin.settings.theme = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Notifications").setDesc("Show notifications for completed tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.notifications).onChange(async (value) => {
      this.plugin.settings.notifications = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u2B50 Favorite Models" });
    containerEl.createEl("p", {
      text: "Quick access models shown in the toolbar (provider/model format)",
      cls: "setting-item-description"
    });
    this.plugin.settings.favoriteModels.forEach((model, index) => {
      new import_obsidian.Setting(containerEl).setName(`Favorite ${index + 1}`).addText((text) => text.setValue(model).onChange(async (value) => {
        this.plugin.settings.favoriteModels[index] = value;
        await this.plugin.saveSettings();
      })).addButton((button) => button.setIcon("trash").setTooltip("Remove").onClick(async () => {
        this.plugin.settings.favoriteModels.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("+ Add Favorite").onClick(async () => {
      this.plugin.settings.favoriteModels.push("provider/model-name");
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};

// src/ProcessManager.ts
var import_child_process = require("child_process");
var import_util = require("util");
var fs = __toESM(require("fs"));
var import_events2 = require("events");

// src/StreamParser.ts
var import_events = require("events");
var StreamParser = class extends import_events.EventEmitter {
  constructor() {
    super();
    this.buffer = "";
    this.currentSessionID = null;
    this.pendingTools = /* @__PURE__ */ new Map();
  }
  feed(data) {
    this.buffer += data;
    this.processBuffer();
  }
  processBuffer() {
    const lines = this.buffer.split("\n");
    this.buffer = lines.pop() || "";
    for (const line of lines) {
      if (!line.trim())
        continue;
      this.parseLine(line.trim());
    }
  }
  parseLine(line) {
    try {
      const event = JSON.parse(line);
      this.handleEvent(event);
    } catch (e) {
      if (line.trim()) {
        this.emit("event", {
          type: "text",
          content: line,
          messageID: "raw"
        });
      }
    }
  }
  handleEvent(event) {
    if (event.sessionID && !this.currentSessionID) {
      this.currentSessionID = event.sessionID;
      this.emit("event", {
        type: "session",
        sessionID: event.sessionID
      });
    }
    switch (event.type) {
      case "step_start":
        this.emit("event", { type: "step_start" });
        break;
      case "text":
        if (event.part.text) {
          this.emit("event", {
            type: "text",
            content: event.part.text,
            messageID: event.part.messageID
          });
        }
        break;
      case "tool_use":
        this.handleToolEvent(event);
        break;
      case "step_finish":
        this.emit("event", {
          type: "step_finish",
          reason: event.part.reason,
          tokens: event.part.tokens,
          cost: event.part.cost
        });
        break;
      case "error":
        this.emit("event", {
          type: "error",
          message: event.part.text || "Unknown error"
        });
        break;
    }
  }
  handleToolEvent(event) {
    const part = event.part;
    const callID = part.callID || part.id;
    const state = part.state;
    const toolEvent = {
      type: "tool",
      toolName: part.tool || "unknown",
      callID,
      status: (state == null ? void 0 : state.status) || "pending",
      input: state == null ? void 0 : state.input,
      output: state == null ? void 0 : state.output,
      title: state == null ? void 0 : state.title,
      error: state == null ? void 0 : state.error
    };
    this.pendingTools.set(callID, toolEvent);
    this.emit("event", toolEvent);
  }
  getSessionID() {
    return this.currentSessionID;
  }
  reset() {
    this.buffer = "";
    this.currentSessionID = null;
    this.pendingTools.clear();
  }
  flush() {
    if (this.buffer.trim()) {
      this.parseLine(this.buffer.trim());
      this.buffer = "";
    }
  }
};

// src/ProcessManager.ts
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var access = fs.promises.access;
var { constants } = fs;
var ProcessManager = class extends import_events2.EventEmitter {
  constructor(settings, vaultPath) {
    super();
    this.process = null;
    this.state = {
      isRunning: false,
      pid: null,
      lastError: null,
      sessionID: null
    };
    this.messageQueue = [];
    this.isProcessingQueue = false;
    this.settings = settings;
    this.vaultPath = vaultPath;
    this.parser = new StreamParser();
    this.setupParserListeners();
  }
  setupParserListeners() {
    this.parser.on("event", (event) => {
      switch (event.type) {
        case "text":
          this.emit("text", event.content);
          break;
        case "tool": {
          const toolEvent = event;
          const emitEvent = {
            name: toolEvent.toolName,
            status: toolEvent.status,
            title: toolEvent.title,
            input: toolEvent.input,
            output: toolEvent.output,
            error: toolEvent.error
          };
          this.emit("tool", emitEvent);
          break;
        }
        case "step_start":
          this.emit("step-start");
          break;
        case "step_finish": {
          const stepEvent = event;
          const finishEvent = {
            reason: stepEvent.reason,
            tokens: stepEvent.tokens,
            cost: stepEvent.cost
          };
          this.emit("step-finish", finishEvent);
          break;
        }
        case "session":
          this.state.sessionID = event.sessionID;
          this.emit("session", this.state.sessionID);
          break;
        case "error":
          this.emit("parse-error", event.message);
          break;
      }
    });
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getState() {
    return { ...this.state };
  }
  async findOpenCodePath() {
    if (this.settings.opencodePath && this.settings.opencodePath.trim() !== "") {
      return this.settings.opencodePath;
    }
    const possiblePaths = [
      "/opt/homebrew/bin/opencode",
      "/usr/local/bin/opencode",
      "/usr/bin/opencode",
      `${process.env.HOME}/.local/bin/opencode`,
      `${process.env.HOME}/bin/opencode`,
      `${process.env.HOME}/Developer/opencode-patch/opencode/packages/opencode/dist/opencode-darwin-arm64/bin/opencode`
    ];
    for (const path of possiblePaths) {
      try {
        await access(path, constants.X_OK);
        return path;
      } catch (e) {
        continue;
      }
    }
    try {
      const { stdout } = await execAsync("which opencode");
      if (stdout && stdout.trim()) {
        return stdout.trim();
      }
    } catch (e) {
    }
    return "opencode";
  }
  async installOpenCode() {
    try {
      await execAsync("npm install -g @opencode/cli", { timeout: 12e4 });
      const { stdout } = await execAsync("which opencode");
      const path = stdout.trim();
      if (path) {
        return {
          success: true,
          message: "OpenCode CLI installed successfully via npm",
          path
        };
      } else {
        return {
          success: false,
          message: "Installation completed but executable not found in PATH"
        };
      }
    } catch (npmError) {
      try {
        await execAsync("curl -fsSL https://install.opencode.ai | sh", { timeout: 12e4 });
        const { stdout } = await execAsync("which opencode");
        const path = stdout.trim();
        if (path) {
          return {
            success: true,
            message: "OpenCode CLI installed successfully via installer script",
            path
          };
        } else {
          return {
            success: false,
            message: "Installation completed but executable not found in PATH"
          };
        }
      } catch (curlError) {
        return {
          success: false,
          message: `Failed to install OpenCode CLI. Please install manually from https://opencode.ai or run: npm install -g @opencode/cli`
        };
      }
    }
  }
  async checkOpenCodeInstalled() {
    try {
      const path = await this.findOpenCodePath();
      const { stdout } = await execAsync(`"${path}" --version`);
      return {
        installed: true,
        version: stdout.trim(),
        path
      };
    } catch (error) {
      return { installed: false, error: error instanceof Error ? error.message : String(error) };
    }
  }
  async getAvailableModels() {
    try {
      const path = await this.findOpenCodePath();
      const { stdout } = await execAsync(`"${path}" models`, { timeout: 3e4 });
      const models = stdout.trim().split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
      return models;
    } catch (e) {
      return [];
    }
  }
  async getAuthProviders() {
    try {
      const path = await this.findOpenCodePath();
      const { stdout } = await execAsync(`"${path}" auth list`, { timeout: 1e4 });
      const lines = stdout.trim().split("\n");
      const providers = [];
      for (const line of lines) {
        const match = line.match(/â—?\s*(.+?)\s*\[(.+?)\]/);
        if (match) {
          providers.push({
            provider: match[1].trim(),
            type: match[2].trim()
          });
        }
      }
      return providers;
    } catch (e) {
      return [];
    }
  }
  async loginProvider(provider) {
    try {
      const path = await this.findOpenCodePath();
      const process2 = (0, import_child_process.spawn)(path, ["auth", "login", provider], {
        detached: true,
        stdio: "ignore"
      });
      process2.unref();
      return {
        success: true,
        message: `Opening ${provider} login page... Check your browser.`
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to open ${provider} login: ${error}`
      };
    }
  }
  async logoutProvider(provider) {
    try {
      const path = await this.findOpenCodePath();
      await execAsync(`"${path}" auth logout ${provider}`);
      return {
        success: true,
        message: `Logged out from ${provider}`
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to logout from ${provider}: ${error}`
      };
    }
  }
  async start() {
    this.state.isRunning = true;
    this.emit("started", this.state);
  }
  async sendMessage(message) {
    this.messageQueue.push(message);
    if (!this.isProcessingQueue) {
      await this.processQueue();
    }
  }
  async processQueue() {
    if (this.messageQueue.length === 0) {
      this.isProcessingQueue = false;
      return;
    }
    this.isProcessingQueue = true;
    const message = this.messageQueue.shift();
    try {
      await this.executeMessage(message);
    } catch (error) {
      this.emit("error", error instanceof Error ? error.message : String(error));
    }
    await this.processQueue();
  }
  async executeMessage(message) {
    const opencodePath = await this.findOpenCodePath();
    const args = [
      "run",
      "--format",
      "json",
      message
    ];
    if (this.settings.provider !== "default") {
      const modelArg = `${this.settings.provider}/${this.settings.model}`;
      args.splice(2, 0, "-m", modelArg);
    }
    if (this.state.sessionID) {
      args.push("-s", this.state.sessionID);
    }
    const env = { ...process.env, TERM: "dumb", NO_COLOR: "1" };
    if (this.settings.customApiBaseUrl) {
      env["OPENAI_BASE_URL"] = this.settings.customApiBaseUrl;
    }
    return new Promise((resolve, reject) => {
      var _a, _b;
      this.parser.reset();
      this.process = (0, import_child_process.spawn)(opencodePath, args, {
        cwd: this.vaultPath,
        env,
        stdio: ["pipe", "pipe", "pipe"]
      });
      this.state.isRunning = true;
      this.state.pid = this.process.pid || null;
      this.state.lastError = null;
      this.emit("running", this.state);
      (_a = this.process.stdout) == null ? void 0 : _a.on("data", (data) => {
        this.parser.feed(data.toString());
      });
      (_b = this.process.stderr) == null ? void 0 : _b.on("data", (data) => {
        const errorText = data.toString();
        console.error("OpenCode stderr:", errorText);
        this.emit("stderr", errorText);
        if (errorText.includes("API key") || errorText.includes("auth")) {
          this.emit("error", new Error(`Authentication failed: ${errorText.trim()}`));
        } else if (errorText.includes("clipboard")) {
          this.emit("error", new Error(`Clipboard error: ${errorText.trim()} - Please select an image-capable model`));
        } else if (errorText.includes("model")) {
          this.emit("error", new Error(`Model error: ${errorText.trim()}`));
        }
      });
      this.process.on("exit", (code, signal) => {
        this.parser.flush();
        this.state.isRunning = false;
        this.state.pid = null;
        this.process = null;
        if (code !== 0 && code !== null) {
          this.state.lastError = `Process exited with code ${code}`;
          reject(new Error(this.state.lastError));
        } else {
          resolve();
        }
        this.emit("exit", { code, signal });
      });
      this.process.on("error", (error) => {
        this.state.lastError = error.message;
        this.state.isRunning = false;
        this.emit("error", error);
        reject(error);
      });
    });
  }
  async stop() {
    if (!this.process || !this.state.isRunning) {
      return;
    }
    return new Promise((resolve) => {
      var _a, _b;
      (_a = this.process) == null ? void 0 : _a.on("exit", () => {
        resolve();
      });
      (_b = this.process) == null ? void 0 : _b.kill("SIGTERM");
      setTimeout(() => {
        if (this.process && this.state.isRunning) {
          this.process.kill("SIGKILL");
        }
        resolve();
      }, 3e3);
    });
  }
  async restart() {
    await this.stop();
    this.parser.reset();
    this.state.sessionID = null;
    await this.start();
  }
  clearSession() {
    this.state.sessionID = null;
    this.parser.reset();
  }
};

// src/ConversationStore.ts
var STORAGE_KEY = "opencode-conversations";
var MAX_CONVERSATIONS = 20;
var ConversationStore = class {
  constructor(plugin) {
    this.conversations = [];
    this.activeConversationId = null;
    this.plugin = plugin;
  }
  async load() {
    const data = await this.plugin.loadData();
    if (data && data[STORAGE_KEY]) {
      this.conversations = data[STORAGE_KEY] || [];
      this.activeConversationId = data["activeConversationId"] || null;
    }
  }
  async save() {
    const data = await this.plugin.loadData() || {};
    data[STORAGE_KEY] = this.conversations.slice(0, MAX_CONVERSATIONS);
    data["activeConversationId"] = this.activeConversationId;
    await this.plugin.saveData(data);
  }
  createConversation(title) {
    const conversation = {
      id: `conv-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
      title: title || this.generateTitle(),
      messages: [],
      sessionID: null,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    this.conversations.unshift(conversation);
    this.activeConversationId = conversation.id;
    this.save();
    return conversation;
  }
  generateTitle() {
    const now = /* @__PURE__ */ new Date();
    return now.toLocaleString(void 0, {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }
  getActiveConversation() {
    if (!this.activeConversationId) {
      return null;
    }
    return this.conversations.find((c) => c.id === this.activeConversationId) || null;
  }
  setActiveConversation(id) {
    const conversation = this.conversations.find((c) => c.id === id);
    if (conversation) {
      this.activeConversationId = id;
      this.save();
    }
    return conversation || null;
  }
  getConversationList() {
    return this.conversations.map((c) => ({
      id: c.id,
      title: c.title,
      updatedAt: c.updatedAt,
      messageCount: c.messages.length
    }));
  }
  updateConversation(id, updates) {
    const conversation = this.conversations.find((c) => c.id === id);
    if (conversation) {
      Object.assign(conversation, updates, { updatedAt: Date.now() });
      this.save();
    }
  }
  addMessage(conversationId, message) {
    const conversation = this.conversations.find((c) => c.id === conversationId);
    if (conversation) {
      conversation.messages.push(message);
      conversation.updatedAt = Date.now();
      if (conversation.messages.length === 1 && message.role === "user") {
        conversation.title = message.content.substring(0, 50) + (message.content.length > 50 ? "..." : "");
      }
      this.save();
    }
  }
  deleteConversation(id) {
    var _a;
    const index = this.conversations.findIndex((c) => c.id === id);
    if (index !== -1) {
      this.conversations.splice(index, 1);
      if (this.activeConversationId === id) {
        this.activeConversationId = ((_a = this.conversations[0]) == null ? void 0 : _a.id) || null;
      }
      this.save();
    }
  }
  getOrCreateActiveConversation() {
    let conversation = this.getActiveConversation();
    if (!conversation) {
      conversation = this.createConversation();
    }
    return conversation;
  }
};

// src/ChatView.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_OPENCODE_CHAT = "opencode-chat-view";
var OpenCodeChatView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentAssistantContent = "";
    this.currentAssistantEl = null;
    this.isStreaming = false;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_OPENCODE_CHAT;
  }
  getDisplayText() {
    return "OpenCode";
  }
  getIcon() {
    return "terminal";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("opencode-container");
    this.createHeader(container);
    this.messagesContainer = container.createDiv({ cls: "opencode-messages" });
    this.inputContainer = container.createDiv({ cls: "opencode-input-container" });
    this.createInputArea();
    this.setupProcessListeners();
    await this.loadConversation();
  }
  async loadConversation() {
    const conversation = this.plugin.conversationStore.getOrCreateActiveConversation();
    this.renderConversation(conversation);
  }
  async renderConversation(conversation) {
    this.messagesContainer.empty();
    if (conversation.messages.length === 0) {
      this.addSystemMessage("Welcome to Master of OpenCode! \u{1F680}\nPowered by OpenCode CLI with multi-model support.");
    } else {
      for (const msg of conversation.messages) {
        await this.renderMessage(msg);
      }
    }
  }
  async renderMessage(msg) {
    switch (msg.role) {
      case "user":
        this.renderUserMessage(msg.content);
        break;
      case "assistant":
        await this.renderAssistantMessage(msg.content);
        break;
      case "tool":
        if (msg.toolName && msg.toolStatus) {
          this.renderToolMessage({
            name: msg.toolName,
            status: msg.toolStatus,
            title: msg.toolTitle,
            input: msg.toolInput,
            output: msg.toolOutput
          });
        }
        break;
      case "system":
        this.addSystemMessage(msg.content);
        break;
    }
  }
  renderUserMessage(content) {
    const msgEl = this.messagesContainer.createDiv({ cls: "opencode-message opencode-message-user" });
    const contentEl = msgEl.createDiv({ cls: "opencode-message-content" });
    contentEl.textContent = content;
  }
  async renderAssistantMessage(content) {
    const msgEl = this.messagesContainer.createDiv({ cls: "opencode-message opencode-message-assistant" });
    const contentEl = msgEl.createDiv({ cls: "opencode-message-content" });
    await import_obsidian2.MarkdownRenderer.render(this.app, content, contentEl, "", this.plugin);
  }
  renderToolMessage(event) {
    const msgEl = this.messagesContainer.createDiv({ cls: "opencode-message opencode-message-tool" });
    this.updateToolElement(msgEl, event);
  }
  createHeader(container) {
    const header = container.createDiv({ cls: "opencode-header" });
    const titleArea = header.createDiv({ cls: "opencode-header-title" });
    titleArea.createSpan({ text: "\u26A1", cls: "opencode-logo" });
    titleArea.createSpan({ text: "OpenCode", cls: "opencode-title" });
    const modelArea = header.createDiv({ cls: "opencode-header-model" });
    const modelSelector = modelArea.createEl("select", { cls: "opencode-model-selector" });
    IMAGE_CAPABLE_MODELS.forEach((model) => {
      const option = modelSelector.createEl("option", { value: model, text: `${model} \u{1F5BC}\uFE0F` });
      if (model === `${this.plugin.settings.provider}/${this.plugin.settings.model}`) {
        option.selected = true;
      }
    });
    const currentModel = `${this.plugin.settings.provider}/${this.plugin.settings.model}`;
    if (!IMAGE_CAPABLE_MODELS.includes(currentModel)) {
      modelSelector.createEl("option", {
        value: currentModel,
        text: currentModel,
        attr: { selected: "true" }
      });
    }
    modelSelector.addEventListener("change", async (e) => {
      var _a;
      const value = e.target.value;
      const [provider, ...modelParts] = value.split("/");
      const model = modelParts.join("/");
      this.plugin.settings.provider = provider;
      this.plugin.settings.model = model;
      await this.plugin.saveSettings();
      (_a = this.plugin.processManager) == null ? void 0 : _a.clearSession();
      this.updateStatusIndicator();
    });
    this.statusArea = header.createDiv({ cls: "opencode-header-status" });
    this.updateStatusIndicator();
    const actionsArea = header.createDiv({ cls: "opencode-header-actions" });
    const addNoteBtn = actionsArea.createEl("button", {
      cls: "opencode-btn opencode-btn-icon",
      attr: { title: "Add Active Note to Context" }
    });
    addNoteBtn.innerHTML = "\u{1F4C4}";
    addNoteBtn.addEventListener("click", () => this.addActiveNoteToContext());
    this.historyBtn = actionsArea.createEl("button", {
      cls: "opencode-btn opencode-btn-icon",
      attr: { title: "Conversation History" }
    });
    this.historyBtn.innerHTML = "\u{1F4DC}";
    this.historyBtn.addEventListener("click", (e) => this.showHistoryMenu(e));
    const newChatBtn = actionsArea.createEl("button", {
      cls: "opencode-btn opencode-btn-icon",
      attr: { title: "New Chat" }
    });
    newChatBtn.innerHTML = "\u2795";
    newChatBtn.addEventListener("click", () => this.startNewConversation());
    const settingsBtn = actionsArea.createEl("button", {
      cls: "opencode-btn opencode-btn-icon",
      attr: { title: "Settings" }
    });
    settingsBtn.innerHTML = "\u2699\uFE0F";
    settingsBtn.addEventListener("click", () => {
      this.app.setting.open();
      this.app.setting.openTabById("master-of-opencode");
    });
  }
  showHistoryMenu(e) {
    const menu = new import_obsidian2.Menu();
    const conversations = this.plugin.conversationStore.getConversationList();
    const activeConv = this.plugin.conversationStore.getActiveConversation();
    if (conversations.length === 0) {
      menu.addItem((item) => {
        item.setTitle("No conversations yet");
        item.setDisabled(true);
      });
    } else {
      conversations.slice(0, 10).forEach((conv) => {
        menu.addItem((item) => {
          const isActive = (activeConv == null ? void 0 : activeConv.id) === conv.id;
          item.setTitle(`${isActive ? "\u25CF " : ""}${conv.title}`);
          item.onClick(() => {
            var _a, _b;
            const conversation = this.plugin.conversationStore.setActiveConversation(conv.id);
            if (conversation) {
              this.renderConversation(conversation);
              (_a = this.plugin.processManager) == null ? void 0 : _a.clearSession();
              if (conversation.sessionID) {
                (_b = this.plugin.processManager) == null ? void 0 : _b.getState();
              }
            }
          });
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("\u{1F5D1}\uFE0F Clear All History");
        item.onClick(async () => {
          conversations.forEach((conv) => {
            this.plugin.conversationStore.deleteConversation(conv.id);
          });
          this.startNewConversation();
        });
      });
    }
    menu.showAtMouseEvent(e);
  }
  updateStatusIndicator() {
    var _a;
    this.statusArea.empty();
    const state = (_a = this.plugin.processManager) == null ? void 0 : _a.getState();
    if (this.isStreaming) {
      this.statusArea.createSpan({ text: "\u{1F535}", cls: "status-dot" });
      this.statusArea.createSpan({ text: "Streaming...", cls: "status-text" });
    } else if (state == null ? void 0 : state.sessionID) {
      this.statusArea.createSpan({ text: "\u{1F7E2}", cls: "status-dot" });
      this.statusArea.createSpan({ text: "Connected", cls: "status-text" });
    } else {
      this.statusArea.createSpan({ text: "\u26AA", cls: "status-dot" });
      this.statusArea.createSpan({ text: "Ready", cls: "status-text" });
    }
  }
  createInputArea() {
    this.inputField = this.inputContainer.createEl("textarea", {
      cls: "opencode-input",
      attr: {
        placeholder: "Ask OpenCode anything... (Shift+Enter for new line)",
        rows: "1"
      }
    });
    this.inputField.addEventListener("input", () => {
      this.inputField.style.height = "auto";
      this.inputField.style.height = Math.min(this.inputField.scrollHeight, 200) + "px";
    });
    this.inputField.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
    const sendBtn = this.inputContainer.createEl("button", {
      cls: "opencode-send-btn",
      text: "\u27A4"
    });
    sendBtn.addEventListener("click", () => this.sendMessage());
  }
  setupProcessListeners() {
    if (!this.plugin.processManager)
      return;
    this.plugin.processManager.on("text", (content) => {
      this.appendAssistantText(content);
    });
    this.plugin.processManager.on("tool", (event) => {
      this.handleToolEvent(event);
    });
    this.plugin.processManager.on("step-start", () => {
      this.isStreaming = true;
      this.updateStatusIndicator();
    });
    this.plugin.processManager.on("step-finish", (event) => {
      this.finalizeAssistantMessage();
      if (event.tokens) {
        this.showTokenUsage(event.tokens);
      }
    });
    this.plugin.processManager.on("session", (sessionID) => {
      const conversation = this.plugin.conversationStore.getActiveConversation();
      if (conversation) {
        this.plugin.conversationStore.updateConversation(conversation.id, { sessionID });
      }
      this.updateStatusIndicator();
    });
    this.plugin.processManager.on("exit", () => {
      this.isStreaming = false;
      this.finalizeAssistantMessage();
      this.updateStatusIndicator();
    });
    this.plugin.processManager.on("error", (error) => {
      this.isStreaming = false;
      const errorMsg = error instanceof Error ? error.message : error;
      if (errorMsg.includes("API key") || errorMsg.includes("auth")) {
        this.addSystemMessage(`\u{1F511} Authentication Error

${errorMsg}

\u{1F4A1} Please check your OpenCode CLI authentication:
1. Open Settings > Authentication Status
2. Ensure your provider is logged in
3. Or run: opencode auth login <provider>`);
      } else if (errorMsg.includes("clipboard")) {
        this.addSystemMessage(`\u{1F5BC}\uFE0F Image Input Error

${errorMsg}

\u{1F4A1} Please select an image-capable model:
Available models marked with \u{1F5BC}\uFE0F in the dropdown above.`);
      } else {
        this.addSystemMessage(`\u274C Error: ${errorMsg}`);
      }
      this.updateStatusIndicator();
    });
  }
  appendAssistantText(content) {
    this.currentAssistantContent += content;
    if (!this.currentAssistantEl) {
      this.currentAssistantEl = this.messagesContainer.createDiv({
        cls: "opencode-message opencode-message-assistant streaming"
      });
    }
    const contentEl = this.currentAssistantEl.querySelector(".opencode-message-content") || this.currentAssistantEl.createDiv({ cls: "opencode-message-content" });
    contentEl.empty();
    import_obsidian2.MarkdownRenderer.render(
      this.app,
      this.currentAssistantContent,
      contentEl,
      "",
      this.plugin
    );
    this.scrollToBottom();
  }
  finalizeAssistantMessage() {
    if (this.currentAssistantEl) {
      this.currentAssistantEl.removeClass("streaming");
      if (this.currentAssistantContent.trim()) {
        const conversation = this.plugin.conversationStore.getActiveConversation();
        if (conversation) {
          const msg = {
            id: Date.now().toString(),
            role: "assistant",
            content: this.currentAssistantContent,
            timestamp: /* @__PURE__ */ new Date()
          };
          this.plugin.conversationStore.addMessage(conversation.id, msg);
        }
      }
    }
    this.currentAssistantEl = null;
    this.currentAssistantContent = "";
    this.isStreaming = false;
  }
  handleToolEvent(event) {
    const existingTool = this.messagesContainer.querySelector(`[data-tool-id="${event.name}-latest"]`);
    if (existingTool && event.status !== "pending") {
      this.updateToolElement(existingTool, event);
    } else if (event.status === "pending" || event.status === "running" || !existingTool) {
      this.createToolElement(event);
    }
  }
  createToolElement(event) {
    const msgEl = this.messagesContainer.createDiv({
      cls: "opencode-message opencode-message-tool",
      attr: { "data-tool-id": `${event.name}-latest` }
    });
    this.updateToolElement(msgEl, event);
    this.scrollToBottom();
    const conversation = this.plugin.conversationStore.getActiveConversation();
    if (conversation) {
      const msg = {
        id: Date.now().toString(),
        role: "tool",
        content: event.title || event.name,
        timestamp: /* @__PURE__ */ new Date(),
        toolName: event.name,
        toolStatus: event.status,
        toolInput: event.input,
        toolOutput: event.output,
        toolTitle: event.title
      };
      this.plugin.conversationStore.addMessage(conversation.id, msg);
    }
  }
  updateToolElement(el, event) {
    const statusIcon = this.getStatusIcon(event.status);
    const statusText = this.getStatusText(event.status);
    const title = event.title || event.name;
    el.empty();
    const block = el.createDiv({ cls: "opencode-tool-block" });
    const header = block.createDiv({ cls: "opencode-tool-header" });
    header.createSpan({ text: statusIcon, cls: "opencode-tool-icon" });
    header.createSpan({ text: title, cls: "opencode-tool-name" });
    header.createSpan({ text: statusText, cls: `opencode-tool-status status-${event.status}` });
    if (event.output && event.status === "completed") {
      const outputEl = block.createDiv({ cls: "opencode-tool-output collapsed" });
      const toggleBtn = header.createEl("button", {
        cls: "opencode-tool-toggle",
        text: "\u25B6"
      });
      toggleBtn.addEventListener("click", () => {
        outputEl.toggleClass("collapsed", !outputEl.hasClass("collapsed"));
        toggleBtn.textContent = outputEl.hasClass("collapsed") ? "\u25B6" : "\u25BC";
      });
      const pre = outputEl.createEl("pre");
      const output = event.output.length > 500 ? event.output.substring(0, 500) + "...\n(truncated)" : event.output;
      pre.textContent = output;
    }
    if (event.error) {
      const errorEl = block.createDiv({ cls: "opencode-tool-error" });
      errorEl.textContent = `Error: ${event.error}`;
    }
  }
  getStatusIcon(status) {
    switch (status) {
      case "pending":
        return "\u23F3";
      case "running":
        return "\u{1F504}";
      case "completed":
        return "\u2705";
      case "error":
        return "\u274C";
      default:
        return "\u2753";
    }
  }
  getStatusText(status) {
    switch (status) {
      case "pending":
        return "Pending";
      case "running":
        return "Running...";
      case "completed":
        return "Done";
      case "error":
        return "Error";
      default:
        return status;
    }
  }
  showTokenUsage(tokens) {
    const usageEl = this.messagesContainer.createDiv({ cls: "opencode-token-usage" });
    usageEl.innerHTML = `<span class="token-label">Tokens:</span> 
			<span class="token-in">\u2193${tokens.input}</span> 
			<span class="token-out">\u2191${tokens.output}</span>
			${tokens.cache ? `<span class="token-cache">\u{1F4E6}${tokens.cache.read}</span>` : ""}`;
  }
  async sendMessage() {
    var _a;
    const message = this.inputField.value.trim();
    if (!message || this.isStreaming)
      return;
    const conversation = this.plugin.conversationStore.getOrCreateActiveConversation();
    const msg = {
      id: Date.now().toString(),
      role: "user",
      content: message,
      timestamp: /* @__PURE__ */ new Date()
    };
    this.plugin.conversationStore.addMessage(conversation.id, msg);
    this.renderUserMessage(message);
    this.inputField.value = "";
    this.inputField.style.height = "auto";
    this.currentAssistantContent = "";
    this.scrollToBottom();
    try {
      await ((_a = this.plugin.processManager) == null ? void 0 : _a.sendMessage(message));
    } catch (error) {
      this.addSystemMessage(`\u274C Failed to send message: ${error}`);
    }
  }
  addSystemMessage(content) {
    const msgEl = this.messagesContainer.createDiv({ cls: "opencode-message opencode-message-system" });
    const contentEl = msgEl.createDiv({ cls: "opencode-message-content" });
    contentEl.textContent = content;
    this.scrollToBottom();
  }
  scrollToBottom() {
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  async addActiveNoteToContext() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.addSystemMessage("No active file to add.");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const message = `Please analyze this file: ${activeFile.path}

\`\`\`
${content}
\`\`\``;
    this.inputField.value = message;
    this.addSystemMessage(`\u{1F4C4} Added "${activeFile.name}" to context. Press Enter to send.`);
  }
  startNewConversation() {
    var _a;
    (_a = this.plugin.processManager) == null ? void 0 : _a.clearSession();
    const conversation = this.plugin.conversationStore.createConversation();
    this.renderConversation(conversation);
  }
  async onClose() {
    await this.plugin.conversationStore.save();
  }
};

// src/main.ts
var OpenCodePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.processManager = null;
  }
  async onload() {
    console.log("Loading Master of OpenCode plugin");
    await this.loadSettings();
    this.conversationStore = new ConversationStore(this);
    await this.conversationStore.load();
    const vaultPath = this.app.vault.adapter.basePath;
    this.processManager = new ProcessManager(this.settings, vaultPath);
    this.registerView(
      VIEW_TYPE_OPENCODE_CHAT,
      (leaf) => new OpenCodeChatView(leaf, this)
    );
    this.addRibbonIcon("terminal", "Open OpenCode", async () => {
      await this.activateView();
    });
    this.addCommand({
      id: "open-opencode-chat",
      name: "Open OpenCode Chat",
      callback: async () => {
        await this.activateView();
      }
    });
    this.addCommand({
      id: "send-file-to-opencode",
      name: "Send Active File to OpenCode",
      editorCallback: async (editor, view) => {
        const content = editor.getValue();
        const file = view.file;
        if (file && this.processManager) {
          const message = `Analyze this file: ${file.path}

\`\`\`
${content}
\`\`\``;
          await this.activateView();
          await this.processManager.sendMessage(message);
        }
      }
    });
    this.addSettingTab(new OpenCodeSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!(file instanceof import_obsidian3.TFile))
          return;
        menu.addItem((item) => {
          item.setTitle("Send to OpenCode").setIcon("terminal").onClick(async () => {
            var _a;
            const content = await this.app.vault.read(file);
            await this.activateView();
            const message = `Please analyze this file: ${file.path}

\`\`\`
${content}
\`\`\``;
            await ((_a = this.processManager) == null ? void 0 : _a.sendMessage(message));
          });
        });
      })
    );
    console.log("Master of OpenCode plugin loaded");
  }
  async onunload() {
    console.log("Unloading Master of OpenCode plugin");
    if (this.processManager) {
      await this.processManager.stop();
      this.processManager = null;
    }
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_OPENCODE_CHAT);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.processManager) {
      this.processManager.updateSettings(this.settings);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_OPENCODE_CHAT);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_OPENCODE_CHAT,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
